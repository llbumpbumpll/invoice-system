// Customer routes (เส้นทาง API สำหรับลูกค้า)
// Example usage: GET /api/customers
import { Router } from "express";
import { pool } from "../db/pool.js";

const r = Router();

// List customers
r.get("/", async (_, res) => {
  const { rows } = await pool.query("select id, code, name from customer order by name");
  res.json(rows);
});

// Create customer (supports auto code)
r.post("/", async (req, res) => {
  let { code, name, address_line1, address_line2, country_id, credit_limit } = req.body;
  try {
    if (!code || code.trim() === "") {
      // Auto-generate code: Get max ID to estimate next sequence, or rely on serial if possible.
      // For simplicity and since we don't have a sequence for code, we'll fetch max ID + 1.
      // Or cleaner: Insert first ensuring ID, then update code? No, 'code' might be unique/required constraint.
      // Let's assume loose pattern "C" + next_id. (This is race-condition prone in high concurrency but okay for this lab).
      const maxRes = await pool.query("SELECT MAX(id) as m FROM customer");
      const nextId = (maxRes.rows[0].m || 0) + 1;
      code = `C${nextId.toString().padStart(3, '0')}`;
    }

    // Check if ID is auto-increment. In sql_run.sql it's generated by default as identity.
    const { rows } = await pool.query(
      "INSERT INTO customer (code, name, address_line1, address_line2, country_id, credit_limit) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id",
      [code, name, address_line1, address_line2, country_id, credit_limit]
    );
    res.status(201).json({ id: rows[0].id, code });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

r.put("/:id", async (req, res) => {
  const { id } = req.params;
  const { code, name, address_line1, address_line2, country_id, credit_limit } = req.body;
  try {
    await pool.query(
      "UPDATE customer SET code=$1, name=$2, address_line1=$3, address_line2=$4, country_id=$5, credit_limit=$6 WHERE id=$7",
      [code, name, address_line1, address_line2, country_id, credit_limit, id]
    );
    res.json({ ok: true });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

// DELETE customer
// Supports ?force=true to delete associated invoices
r.delete("/:id", async (req, res) => {
  const client = await pool.connect();
  try {
    const force = req.query.force === 'true';
    await client.query("begin");

    // If force is true, delete invoices first
    if (force) {
      // Find invoices for this customer
      const invs = await client.query("SELECT id FROM invoice WHERE customer_id=$1", [req.params.id]);
      const invIds = invs.rows.map(i => i.id);

      if (invIds.length > 0) {
        // Delete invoice line items first
        await client.query("DELETE FROM invoice_line_item WHERE invoice_id = ANY($1::int[])", [invIds]);
        // Delete invoices
        await client.query("DELETE FROM invoice WHERE id = ANY($1::int[])", [invIds]);
      }
    }

    await client.query("DELETE FROM customer WHERE id=$1", [req.params.id]);
    await client.query("commit");
    res.json({ ok: true });
  } catch (err) {
    await client.query("rollback");
    // Handle FK constraint violation
    if (err.code === '23503') {
      return res.status(400).json({ error: "Cannot delete customer because they have existing invoices." });
    }
    res.status(500).json({ error: err.message });
  } finally {
    client.release();
  }
});

r.get("/countries", async (_, res) => {
  const { rows } = await pool.query("SELECT id, code, name FROM country ORDER BY name");
  res.json(rows);
});

export default r;
